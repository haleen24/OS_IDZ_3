## Отчет

### Работу выполнил Степанов Роман Андреевич, студент группы БПИ227

### Вариант 33

### Условие:

Пляшущие человечки. На тайном собрании глав преступного
мира города Лондона председатель собрания профессор Мориарти постановил: отныне вся переписка между преступниками должна
вестись тайнописью. В качестве стандарта были выбраны «пляшущие человечки», шифр, в котором каждой букве латинского
алфавита соответствует хитроумный значок.
Реализовать клиент–серверное приложение, шифрующее
исходный текст (в качестве ключа используется кодовая
таблица, устанавливающая однозначное соответствие
между каждой буквой и каким–нибудь числом).
Каждый процесс–шифровальщик является клиентом. Он кодирует свои кусочки общего текста. При решении использовать
парадигму портфеля задач. клиенты работают асинхронно, формируя свой закодированный фрагмент в случайное время.
Следовательно, при занесении информации в портфель–сервер необходимо проводить упорядочение фрагментов.
В программе необходимо вывести исходный текст, закодированные
фрагменты по мере их формирования, окончательный закодированный текст.

### Сценарий:

Программа сервер получает на вход сообщение, которое должно быть зашифровано, делит его на части и отдает клиентам.
Клиенты, после получения части сообщения, шифруют его и отправляют обратно на сервер

### Об аргументах:

Сервер принимает на вход: <ip> <port> <number> <message>.
number - число клиентов, которые будут шифровать сообщения.
Клиент принимает на вход: <ip> <port>, по которому клиент должен постучаться, чтобы попасть на сервер

# Предполагаемая оценка - 10 баллов

На каждую оценку разработана отдельная программа, которая является модификацией предыдущей. Базовые понятия описаны в
решении на 4-5 баллов, далее в каждом критерии указан список изменений

# Критерии на 4-5 баллов:

## Решение:

В папке 4-5 два файла: server.cpp и client.cpp.

server.cpp - сервер, который должен быть запущен первым. Принимает на вход ip, port, n, message. Ждет подключения n
клиентов, которые подтвердят свой статус шифровальщиков сообщением "worker". Делит message на части,
динной ```TASK_SIZE``` (#define в файле lib.h) и отправляет их клиентов. Отправление работает следующим образом: сервер
обходит список рабочих и отдает им кусок сообщения. Если список закончился - то сервер продолжает отсылать сообщения,
обнулив при этом счетчик списке клиентов. Далее сервер получает ответы от клиентов - в конфигруации на оценку 4-5
баллов, сервер синхронно собирает ответы в том порядке, в котором он их раздал (это изменено в решениях на большую
оценку).
После того как сервер собрал ответы, он выводит их на экран.
client.cpp - клиент, который должен быть запущен только после запуска сервера (иначе, он не сможет с ним соединиться).
Получает на вход ip адрес и порт сервар. После принятия сервером, отсылает ему сообщение "worker". Получает от сервера
сообщения, которые шифрует при помощи метода encode (из файла encode.h). Для этого метода используется словарь, который
находится в том же .h файле. Перед использованием - его надо проинициализировать. Функция инициализации позволяет при
отсутствии переданных аргументов сделать стандартную иницилазицию - каждому символу сопоставят символ, аски код которого
больше его самого на SHIFT (#define в lib.h) (в случае, если полученное число больше 128 - берется остаток от этого
числа по модулю 128). Словарь типа <char, char>, для дого чтобы длина задания и ответа совпадала - возможно
уницицированное чтение пакетов.
файлы lib.h и lib.cpp содержат определения и реализацию важных функций, используемых в программе.

# Критерии на 6-7 баллов:

В рамках оценивания, на 6-7 и 8 баллов сдана одна программа, т. к. изначальное самое просто решение удовлетворяет как
критериям на 6-7 баллов, так и критерям на 8 баллов (данный пункт был согласован с преподавателем :heart: ).

Создан отдельный файл observer с такими же параметрами запуска, как и обычный клиент. При подключению к серверу он
сообщает последнему, что является наблюдаетелем. Также были добавлены изменения в вывод клиента. Изменения сервера
описаны в следующем пункте

# Критерии на 8 баллов:

Изменения:
Сервер после приема n шифровальщиков (если во время приема шифровальщиков принимается наблюдатель - то сервер просто
сохраняет его, но не засчитывает как шифорвальщика) поднимает отдельный поток, который ждет подключения наблюдателей.
Так же сервер отсылает логи всем наблюдателем, для этого используется отдельный поток на каждый лог, для синхронизации
коллекции наблюдателей между посылкой логов и принятием новых слушателей используется мьютех в глобальной памяти.
Каждому поток передается поинтер на кучу, по которому можно найти сообщение, которое надо отправить. После того как
сервер получит все ответы, он закрывает все сокеты и уничтожает мьютекс

# Критерии на 9-10 баллов

Для оценки на 10 баллов решение было полностью пересмотрено и переделано. Итак:
теперь сервер не требует от пользователя количество рабочих - их можно подключать на лету. Для удобства на сервере
добавлен этап ожидания - press enter to start - это надо, для того чтобы успеть подключить желаемое количество клиентов.
Большое количество данных были перемещены в глобальную память. Это связано с многопоточностью.

Самое важное:

* Раньше всех поднимается поток, который ожидает подключения от клиентов. Здесь, как раньше - после подключения клиент
  говорит кто он. Если это рабочий, то сервер запоминает его сокет как сокет шифровальщика и кидает сигнал на условную
  переменную, которая отвечает за то, что в текущий момент времени множество сокетов рабочих не пусто. Если это
  наблюдатель - то сервер просто принимает его. Если это не рабочий и не наблюдатель - сервер отключает его.

* Следом поднимается поток, который отвечает за прием сообщений. На каждый дескриптор рабочего выдается по потоку,
  который ждет ответа. После того как всем дескрипторам на данном этапе разданы потоки, глав-поток ожидает их (делает
  join). Если клиент отвалился - то на сервер в recv придет 0, и тогда сервер удалит дескриптор из рабочих. Благодаря
  этому происходит слушаенье всех ответов. После полного цикла сбора информации - глав-поток снова запускает потоки,
  которые ожидают чтения
* Далее в главном потоке происходит раздача задач заданий таким образом: если нет открытых сокетов рабочих - ждать
  сигнала по условной переменной. Когда есть хотя бы один рабочий - взять следующее не сделанное задание (по умолчанию в
  массиве ответов все задания имеют id = -1, то есть задание считается не сделанным, если по его индексу в массиве
  ответов лежит ответ с id = -1). Дать задание текущему рабочему. Если в процессе отправки происходит ошибка или
  выясняется, что рабочий отвалился - выкинуть его дескриптор из массива дескрипторов рабочих и не изменяя параметров
  повторить цикл заново. Если задача отправлена, то увеличить индекс связанные с позицией в массиве рабочих (то есть
  пойти к следующему рабочему) и индекс не сделанной задачи. После отправки сообщения, сервер делает паузу (sleep) на 30
  милисекунд. Сделано это, чтобы не засорять канал сообщений по сокету. Цикл раздачи заданий завершается, когда для всех
  ответов в массиве ответов id != -1. После приема всех ответов сервер проходит по ним в том порядке, в котором задания
  были созданы и выводит их еще раз
* Также для каждого сообщений наблюдателям поднимается отдельный поток, который проходит по всем дескритпорам и
  отправляет сообщения наблюдателям
* Этим пунктом описывается критерий на 10 баллов. В конце программы происходит закрытие всех дескрипторов, посылается
  сигнал всем потокам о завершениии, уничтожаются
  мьютексы. Клиент понимает, что сервер закончил работу, когда при получении очередного пакета ему возвращается 0 (Т. к.
  сервер не посылает пустых сообщений, то сообщение размера 0 равносильно окончанию программы). Кроме того у наблюдателя
  есть отдельный механизм завершения - когда приходит сообщение exit.

А это моя кошка по имени Клюква, ей всего 2-3 месяца, мы нашли ее недавно. Надеюсь вам понравится
![](Cat/photo_2024-05-19_16-42-47.jpg "Кощка")

![](Cat/photo_2024-05-19_16-42-48.jpg)